/*
 * Copyright (C) 2003 Robert Kooima
 *
 * NEVERBALL is  free software; you can redistribute  it and/or modify
 * it under the  terms of the GNU General  Public License as published
 * by the Free  Software Foundation; either version 2  of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT  ANY  WARRANTY;  without   even  the  implied  warranty  of
 * MERCHANTABILITY or  FITNESS FOR A PARTICULAR PURPOSE.   See the GNU
 * General Public License for more details.
 */

#include "progress.h"
#include "config.h"
#include "demo.h"
#include "level.h"
#include "set.h"
#include "lang.h"
#include "score.h"
#include "audio.h"

#include "game_common.h"
#include "game_client.h"
#include "game_server.h"

#include <assert.h>

/*---------------------------------------------------------------------------*/

struct progress
{
    int balls;
    int score;
    int times;
};

static int replay = 0;

static int mode = MODE_NORMAL;

static struct level *level;
static struct level *next;

static int done  =  0;

static struct progress curr[MAX_PLAYERS];
static struct progress prev[MAX_PLAYERS];

/* Set stats. */

static int score_rank = RANK_LAST;
static int times_rank = RANK_LAST;

/* Level stats. */

struct level_progress {
    int status;
    int coins;
    int timer;
    int goal;
    int goal_i;
    int goal_e;
    int time_rank;
    int goal_rank;
    int coin_rank;
};

static struct level_progress lprog[MAX_PLAYERS];

/*---------------------------------------------------------------------------*/

void progress_init(int m)
{
    int p;
    mode  = m;

    replay = 0;

    score_rank = RANK_LAST;
    times_rank = RANK_LAST;

    done  = 0;

    for (p = 0; p < MAX_PLAYERS; p++)
    {
        curr[p].balls = 2;
        curr[p].score = 0;
        curr[p].times = 0;
        prev[p] = curr[p];

        lprog[p].status = GAME_NONE;
        lprog[p].coins = 0;
        lprog[p].timer = 0;
        lprog[p].goal = 0;
        lprog[p].goal_i = 0;
        lprog[p].goal_e = 0;
        lprog[p].time_rank = RANK_LAST;
        lprog[p].goal_rank = RANK_LAST;
        lprog[p].coin_rank = RANK_LAST;
    }
}

static int init_level(void)
{
    demo_play_init(USER_REPLAY_FILE, level, mode,
                   curr[0].score, curr[0].balls, curr[0].times);

    /*
     * Init both client and server, then process the first batch
     * of commands generated by the server to sync client to
     * server.
     */

    if (game_client_init(level_file(level)) &&
        game_server_init(level_file(level), level_time(level), lprog[0].goal_e, mode))
    {
        game_client_sync(demo_fp);
        audio_music_fade_to(2.0f, level_song(level));
        return 1;
    }

    demo_play_stop(1);
    return 0;
}

int  progress_play(struct level *l)
{
    int p;
    if (l)
    {
        level = l;

        next   = NULL;

        for (p = 0; p < MAX_PLAYERS; p++)
        {
            lprog[p].status = GAME_NONE;
            lprog[p].coins  = 0;
            lprog[p].timer  = 0;
            lprog[p].goal   = lprog[p].goal_i = level_goal(level);

            lprog[p].goal_e = (mode != MODE_CHALLENGE && level_completed(level) &&
                               config_get_d(CONFIG_LOCK_GOALS) == 0) || lprog[p].goal == 0;

            prev[p] = curr[p];

            lprog[p].time_rank = RANK_LAST;
            lprog[p].goal_rank = RANK_LAST;
            lprog[p].coin_rank = RANK_LAST;
        }

        return init_level();
    }
    return 0;
}

void progress_step(void)
{
    int p;
    int count = config_get_d(CONFIG_MULTIBALL);
    if (count < 1) count = 1;

    for (p = 0; p < count; p++)
    {
        if (lprog[p].goal > 0)
        {
            lprog[p].goal = lprog[p].goal_i - curr_coins(p);

            if (lprog[p].goal <= 0)
            {
                if (!replay)
                    game_set_goal(p);

                lprog[p].goal = 0;
            }
        }
    }
}

void progress_stat(int s, int p)
{
    int i, dirty = 0;

    if (p < 0 || p >= MAX_PLAYERS) return;

    lprog[p].status = s;

    lprog[p].coins = curr_coins(p);
    lprog[p].timer = (int) (curr_time_elapsed(p) * 100.0f);

    switch (lprog[p].status)
    {
    case GAME_GOAL:

        for (i = curr[p].score + 1; i <= curr[p].score + lprog[p].coins; i++)
            if (progress_reward_ball(i))
                curr[p].balls++;

        curr[p].score += lprog[p].coins;
        curr[p].times += lprog[p].timer;

        dirty = level_score_update(level, lprog[p].timer, lprog[p].coins,
                                   &lprog[p].time_rank,
                                   lprog[p].goal == 0 ? &lprog[p].goal_rank : NULL,
                                   &lprog[p].coin_rank);

        if (!level_completed(level))
        {
            level_complete(level);
            dirty = 1;
        }

        /* Compute next level. */

        if (mode == MODE_CHALLENGE)
        {
            for (next = level->next;
                 next && level_bonus(next);
                 next = next->next)
            {
                if (!level_opened(next))
                {
                    level_open(next);
                    dirty = 1;
                }
            }
        }
        else
        {
            for (next = level->next;
                 next && level_bonus(next) && !level_opened(next);
                 next = next->next)
                /* Do nothing */;
        }

        /* Open next level or complete the set. */

        if (next)
        {
            level_open(next);
            dirty = 1;
        }
        else
            done = mode == MODE_CHALLENGE;

        break;

    case GAME_FALL:
        /* Fall through. */

    case GAME_TIME:
        for (next = level->next;
             next && !level_opened(next);
             next = next->next)
            /* Do nothing */;

        curr[p].times += lprog[p].timer;
        curr[p].balls -= 1;

        break;
    }

    if (dirty && mode != MODE_STANDALONE)
        set_store_hs();

    demo_play_stat(lprog[p].status, lprog[p].coins, lprog[p].timer);
}

void progress_stop(void)
{
    int d;

    if (level)
        d = (curr_clock(0) == level_time(level));
    else
        d = 0;

    demo_play_stop(d);
}

void progress_exit(void)
{
    assert(done);

    if (set_score_update(curr[0].times, curr[0].score, &score_rank, &times_rank))
        set_store_hs();
}

int  progress_replay(const char *filename)
{
    if (demo_replay_init(filename, &lprog[0].goal, &mode,
                         &curr[0].balls,
                         &curr[0].score,
                         &curr[0].times))
    {
        lprog[0].goal_i = lprog[0].goal;
        replay = 1;
        return 1;
    }
    else
        return 0;
}

int  progress_next_avail(void)
{
    if (next)
    {
        if (mode == MODE_CHALLENGE)
            return lprog[0].status == GAME_GOAL;
        else
            return level_opened(next);
    }
    return 0;
}

int  progress_same_avail(void)
{
    switch (lprog[0].status)
    {
    case GAME_NONE:
        return mode != MODE_CHALLENGE;

    default:
        if (mode == MODE_CHALLENGE)
            return !progress_dead();
        else
            return 1;
    }
}

int  progress_next(void)
{
    progress_stop();
    return progress_play(next);
}

int  progress_same(void)
{
    progress_stop();

    /* Reset progress and goal enabled state. */

    if (lprog[0].status == GAME_GOAL)
        curr[0] = prev[0];

    return progress_play(level);
}

int  progress_dead(void)
{
    return mode == MODE_CHALLENGE ? curr[0].balls < 0 : 0;
}

int  progress_done(void)
{
    return done;
}

int  progress_last(void)
{
    return mode != MODE_CHALLENGE && lprog[0].status == GAME_GOAL && !next;
}

int  progress_lvl_high(void)
{
    return (lprog[0].time_rank < RANK_LAST ||
            lprog[0].goal_rank < RANK_LAST ||
            lprog[0].coin_rank < RANK_LAST);
}

int  progress_set_high(void)
{
    return (score_rank < RANK_LAST ||
            times_rank < RANK_LAST);
}

void progress_rename(int set_only)
{
    const char *player = config_get_s(CONFIG_PLAYER);

    if (curr_mode() == MODE_STANDALONE)
    {
        /* HACK Avoid touching the set. */

        level_rename_player(level, lprog[0].time_rank, lprog[0].goal_rank, lprog[0].coin_rank, player);
        demo_rename_player(USER_REPLAY_FILE, player);

        return;
    }

    if (set_only)
    {
        set_rename_player(score_rank, times_rank, player);
    }
    else
    {
        level_rename_player(level, lprog[0].time_rank, lprog[0].goal_rank, lprog[0].coin_rank, player);
        demo_rename_player(USER_REPLAY_FILE, player);

        if (progress_done())
            set_rename_player(score_rank, times_rank, player);
    }

    set_store_hs();
}

int  progress_reward_ball(int s)
{
    return s > 0 && s % 100 == 0;
}

/*---------------------------------------------------------------------------*/

struct level *curr_level(void) { return level; }

int curr_balls(int p) { return (p >= 0 && p < MAX_PLAYERS) ? curr[p].balls : 0; }
int curr_score(int p) { return (p >= 0 && p < MAX_PLAYERS) ? curr[p].score : 0; }
int curr_mode (void) { return mode;       }
int curr_goal (void) { return lprog[0].goal;       }

int progress_time_rank(void) { return lprog[0].time_rank; }
int progress_goal_rank(void) { return lprog[0].goal_rank; }
int progress_coin_rank(void) { return lprog[0].coin_rank; }

int progress_times_rank(void) { return times_rank; }
int progress_score_rank(void) { return score_rank; }

/*---------------------------------------------------------------------------*/

const char *mode_to_str(int m, int l)
{
    switch (m)
    {
    case MODE_CHALLENGE: return l ? _("Challenge Mode") : _("Challenge");
    case MODE_NORMAL:    return l ? _("Normal Mode")    : _("Normal");
    case MODE_STANDALONE:return l ? _("Standalone Mode"): _("Standalone");
    default:             return l ? _("Unknown Mode")   : _("Unknown");
    }
}

/*---------------------------------------------------------------------------*/
